#!/usr/bin/ruby
##
# a shell
require 'ruby_shell'


#puts "$0 #{$0}"
#puts "ARGVS: #{ARGV}"
$original_cmdline = []
File.open("/proc/self/cmdline") {|file| $original_cmdline = file.read.split "\0"}
#puts $original_cmdline
#puts $original_cmdline.length

# comline executable
require 'optparse'

options = {:log_level => Logger::WARN, :name => nil}
parser = OptionParser.new do |opts|
  #opts.banner = "Usage: comline [options] [name]"

  opts.on('-n', '--name', 'Name for the Ruby shell. If not given, it will relaunch with a random name') do |value|
    options[:name] = value
  end

  opts.on('-d', '--debug', 'DEBUG logging level') do |value|
    #$logger.level = Logger::DEBUG
    options[:log_level] = Logger::DEBUG
  end

end

parser.parse!
## now
## get positional argumemts from argv:
#if ARGV.empty?
#  # invent a random name
#  comline_name = "foo"
#else
#  comline_name = ARGV.pop
#end

if not options[:name]
  # relaunch itself
  # with a generated name
  gen_name = 'foo'
  pid = Process.spawn({'RBSHELL_NAME' => gen_name},
                      $original_cmdline.join(' ') + " --name #{gen_name}",
                      :in=>STDIN, :out=>STDOUT, :err=>STDERR)
  Process.wait(pid)
  @last_exit_code = $?.exitstatus

else
  comline_name = 'foo'
  new_shell = Comline.new comline_name
  new_shell.set_log_level options[:log_level]

  # also set the name in environment for other processes
  ENV["RBSHELL_NAME"] = comline_name
  puts "name = #{ENV["RBSHELL_NAME"]}"

  # TODO: make a proper command line utility here and then turn everything into a gem
  exit_code = new_shell.console $global_binding
  #$running_processes.each {|p| exit_code = p[3].value.exitstatus}
  jobs_exit = new_shell.jobs_exit_code
  if jobs_exit
    exit_code = jobs_exit
  end
  Kernel.exit exit_code
end
