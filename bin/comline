#!/usr/bin/ruby
##
# a shell
require 'ruby_shell'
require 'open3'


#puts "$0 #{$0}"
#puts "ARGVS: #{ARGV}"
$original_cmdline = []
File.open("/proc/self/cmdline") {|file| $original_cmdline = file.read.split "\0"}
#puts $original_cmdline
#puts $original_cmdline.length

# comline executable
require 'optparse'

options = {:log_level => Logger::WARN, :name => nil}
parser = OptionParser.new do |opts|
  #opts.banner = "Usage: comline [options] [name]"

  opts.on('-n=NAME', '--name=NAME', 'Name for the Ruby shell. If not given, it will relaunch with a random name') do |value|
    puts "got comline name #{value}"
    options[:name] = value
  end

  opts.on('-d', '--debug', 'DEBUG logging level') do |value|
    #$logger.level = Logger::DEBUG
    options[:log_level] = Logger::DEBUG
  end

  opts.on('-s', '--stdin', 'launch a simple STDIN comline') do |value|
    #$logger.level = Logger::DEBUG
    options[:stdin] = value
  end
end

parser.parse!
puts "parsed! #{options}"

## now
## get positional argumemts from argv:
#if ARGV.empty?
#  # invent a random name
#  comline_name = "foo"
#else
#  comline_name = ARGV.pop
#end

# TODO: use proctable gem
# https://github.com/djberg96/sys-proctable
# TODO: more long-term, check in on Foreman and God process managing gems
#       do job management via one of them?
def find_named_shells
  self_pid = $$
  procs = `ps aux | grep "ruby.*comline.*name" | grep -v "grep\\|#{self_pid}"`
  #procs.map {|p_str| p_str.split[1]} # return PID
  procs.split "\n"
end

def find_shell_by_name name
  self_pid = $$
  procs = `ps aux | grep "ruby.*comline.*name" | grep -v "grep\\|#{self_pid}"`
  #procs.map {|p_str| p_str.split[1]} # return PID
  procs.split "\n"
end

# if name is not given, it makes sense to
# 1) check what named shells already run and suggest to connect to them
# 2) launch a new named shell with a generated name

if not options[:name]
  # relaunch itself
  # with a generated name
  #pid = Process.spawn({'RBSHELL_NAME' => shell_name},
  #                    $original_cmdline.join(' ') + " --name #{shell_name}",
  #                    :in=>STDIN, :out=>STDOUT, :err=>STDERR)
  #Process.wait(pid)
  #last_exit_code = $?.exitstatus
  #Kernel.exit last_exit_code

  named_shells = find_named_shells
  if named_shells.length > 0
    pid = named_shells[0].split() [1]
    new_shell.reconnect pid # process_stdin, process_stdout, process_stderr
    exit_code = new_shell.console
    Kernel.exit exit_code
  end

  #
  # if no existing named shells - generate a name and launch a new one
  shell_name = 'foo'

else
  shell_name = options[:name]
end

=begin
stdin, stdout, stderr, wait_thr = Open3.popen3({'RBSHELL_NAME' => shell_name},
                                              $original_cmdline.join(' ') + " --name #{shell_name}")
stdin.reopen(STDIN)
stdout.reopen(STDOUT)
stderr.reopen(STDERR)
exit_code = wait_thr.value.exitstatus

if exit_code
  Kernel.exit exit_code
else
  Kernel.exit 0
end
=end

puts "got comline name #{shell_name} -- launching new shell"

# if there is a name - set up a Comline object
new_shell = Comline.new shell_name
new_shell.set_log_level options[:log_level]

# also set the name in environment for other processes
ENV["RBSHELL_NAME"] = shell_name
puts "name = #{ENV["RBSHELL_NAME"]}"

# let stdin mean the shell with pipe IO
if options[:stdin]
  exit_code = new_shell.console_stdin $global_binding

else
  # if not stdin -- launch popen3 process with stdin
  puts "got comline name #{shell_name} -- spawn new shell via popen3"
  #command = $original_cmdline.join(' ') + " --name #{shell_name} --stdin"
  # no, launch as is, without stdin
  #command = $original_cmdline.join(' ') + " --name #{shell_name}"
  #puts "#{command}"
  #stdin, stdout, stderr, wait_thr = Open3.popen3({'RBSHELL_NAME' => shell_name},
  #                                              $original_cmdline.join(' ') + " --name #{shell_name} --stdin")
  #stdin, stdout, stderr, wait_thr = Open3.popen3(command)
  #new_shell.reconnect wait_thr[:pid]
  #exit_code = new_shell.console $global_binding
  #puts "done: #{wait_thr} #{exit_code}"

  # no, no pipes, directly connect the terminal
  # just open the comline
  # with direct connection to the terminal
  exit_code = new_shell.console $global_binding

  puts "done: #{exit_code}"
end

if exit_code
  Kernel.exit exit_code
else
  Kernel.exit 0
end
